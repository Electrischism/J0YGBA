// @title Gba File/JWT Auth Server
// @version 1.0
// @description This server is designed to provide jwt token support/local file handling to my gbajs implementation

// @contact.name Nicholas VanCise
// @contact.url https://nicholas-vancise.dev
// @contact.email nvancisedev@gmail.com
// @license.name Copyright (c) 2022 Nicholas VanCise

package main

import (
	_ "auth-server/docs" // docs is generated by Swag CLI, you have to import it.
	"fmt"
	gz "github.com/NYTimes/gziphandler"
	"github.com/gorilla/mux"
	"github.com/natefinch/lumberjack"
	"github.com/rs/cors"
	"github.com/satori/go.uuid"
	"github.com/swaggo/http-swagger"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"log"
	"net/http"
	"os"
	"time"
)

const (
	romPath  = "./local_roms/"
	savePath = "./local_saves/"
	certLoc  = "./certs/fullchain.pem"
	keyLoc   = "./certs/privkey.pem"
)

var (
	userdb        *gorm.DB
	AccessSignKey []byte
)

func serveRequests(port string, certLoc string, keyLoc string, clientHost string) {
	router := mux.NewRouter().StrictSlash(false)
	// here are our handlers for paths to different actions performed by this api are set up, defined in paths.go
	for _, route := range ROUTES {
		if !no_auth_routes[route.pattern] { // path requires authorization
			route.handler = authorize(route.handler).(http.HandlerFunc)
		}

		route.handler = gz.GzipHandler(route.handler).(http.HandlerFunc) // default gzip middleware if accepted

		router.Handle(route.pattern, route.handler).Methods(route.method)
	}

	// cors support
	c := cors.New(cors.Options{
		AllowedOrigins:   []string{clientHost},
		AllowCredentials: true,
		AllowedMethods:   []string{"GET", "POST", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Content-Type", "Content-Length", "Accept-Encoding", "Authorization", "X-Real-Ip", "X-Forwarded-For", "Host", "User-Agent", "Connection"},
		ExposedHeaders:   []string{"Set-Cookie"},
		Debug:            false,
	})

	// below for eventual permanent swagger docs
	/*myRouter.PathPrefix("/documentation/").Handler(httpSwagger.Handler( // if we ever have a stable api deployment, this can be used to make it searchable
		httpSwagger.URL("http://localhost:8081/documentation/doc.json"), // The url pointing to API definition"
	))*/
	router.PathPrefix("/api/documentation/").Handler(httpSwagger.WrapHandler) // swagger documentation endpoint

	log.Fatal(http.ListenAndServeTLS(port, certLoc, keyLoc, c.Handler(router)))
}

func main() {
	fmt.Println("gbajs3 auth server started")
	var err error
	AccessSignKey = uuid.Must(uuid.NewV4(), err).Bytes()
	if err != nil {
		fmt.Println("failed to create initial access secret")
		return
	}
	clientHost := os.Getenv("CLIENT_HOST")

	logfile := &lumberjack.Logger{ // handle rolling logs internally
		Filename:   "./logs/auth_server_log.log",
		MaxSize:    50, // megabytes
		MaxBackups: 5,
		MaxAge:     15,   // days
		Compress:   true, // disabled by default
	}
	log.SetOutput(logfile)

	gconf := &gorm.Config{
		PrepareStmt: true,
		Logger: logger.New(
			log.New(logfile, fmt.Sprintf("\n%s [DEBUG] ", time.Now().String())+"\r\n", 0), // io writer
			logger.Config{
				SlowThreshold:             time.Second,  // Slow SQL threshold
				LogLevel:                  logger.Error, // Log level
				IgnoreRecordNotFoundError: true,         // Ignore ErrRecordNotFound error for logger
				Colorful:                  false,        // Disable color
			},
		),
	}

	userdb, err = newGbaJsDatabase(gconf)
	if err != nil {
		fmt.Println("Error, could not connect to gbajs3 db")
		panic(err)
	}

	err = userdb.AutoMigrate(&User{})
	if err != nil {
		fmt.Println("Error automigrate has failed", err)
	}

	log.Println("handling requests initiated")
	serveRequests(":443", certLoc, keyLoc, clientHost)
}
